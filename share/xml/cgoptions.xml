<tags>
  <item>
    <name>cg.inverse.cgmap</name>
    <desc>
      This option currently only has to be provided for IMC. It specifies the mapping file for
      analysis. Currently also during coarse-grained simulations, a mapping file has to be specified
      which is only a 1:1 mapping. This will change in the future.
    </desc>
  </item>
  <item>
    <name>cg.non-bonded</name>
    <desc>
      Section for a non-bonded interaction. Most of the items in here are identical to items in cg.bonded,
      so they will be described in the same section.
    </desc>
  </item>
  <item>
    <name>cg.bonded</name>
    <desc>
      Section for a bonded interaction. Most of the items in here are identical to items in cg.bonded,
      so they will be described in the same section.
    </desc>
  </item>
  
  <item>
    <name>name</name>
    <desc>
      Name of the interaction. The name can be arbitrary but should be unique. For bonded interactions, this
      should match the name specified in the mapping file.
    </desc>
  </item>
  
  <!-- inverse options -->
  <item>
   <name>inverse.target</name>
   <desc>
     target distribution (e.g. rdf) which is tried to match during iterations to match
   </desc>
  </item>
  <item>
   <name>type1</name>
    <desc>
      Only for non-bonded. Bead type 1 of non-bonded interaction.
    </desc>
  </item>
  <item>
   <name>type2</name>
    <desc>
      Only for non-bonded. Bead type 2 of non-bonded interaction.
    </desc>
  </item>
  <item>
    <name>min</name>
    <desc>
      lower bound of interval for potential table in which calculations are performed.
      Should set based on reference distributions.
    </desc>
  </item>
  <item>
    <name>max</name>
    <desc>
      upper bound of interval for potential table in which calculations are performed.
      Should set based on reference distributions.
    </desc>
  </item>
  <item>
    <name>step</name>
    <desc>
      step size of interval for potential table in which calculations are performed.
      If step site is too small, lots of statistics is needed ( long runs ). If it's too big,
      features in the distribtuion/potentials might get lost.
    </desc>
  </item>
  <item>
    <name>inverse.do_potential</name>
    <default>1</default>
    <desc>
      Update cycle for the potential update. 1 means update, 0 don't update. 1 1 0 means
      update 2 iterations, then don't update, then repeated.
    </desc>
  </item>
  <item>
    <name>inverse.post_update</name>
    <desc>
      Additional post processing of dU before added to potential. This is a list of
      scripts which are called separated by space. The section iterative framework for details.
    </desc>
  </item>
  <item>
    <name>inverse.post_update_options</name>
    <desc>
      This sectioncontains all options for post update scripts.
    </desc>
  </item>
  <item>
    <name>inverse.post_add</name>
    <desc>
      Additional post processing of U after dU added to potential. This is a list of
      scripts which are called separated by space. The section iterative framework for details.
    </desc>
  </item>
  <item>
    <name>inverse.post_add_options</name>
    <desc>
      This sectioncontains all options for post add scripts.
    </desc>
  </item>
  
  <item>
    <name>cg.inverse.restart_file</name>
    <desc>
      Name of the restart file in case a step has to be resumed
    </desc>
  </item>
  <item>
    <name>inverse.particle_dens</name>
    <desc>
      particle densisty of this species (for wjk pressure correction)
    </desc>
  </item>
  <item>
    <name>inverse.post_update_options.pressure.do</name>
    <desc>
      pattern for pressure correction (1 do, 0 do not). Do to pressure correction every third
      step specify "0 0 1", similar to inverse.do_update
    </desc>
  </item>
  <item>
    <name>inverse.post_update_options.pressure.simple.scale</name>
    <desc>
      scaling factor of pressure correction, add details here!!
    </desc>
  </item>
  <item>
    <name>inverse.post_update_options.pressure.type</name>
    <desc>
      Pressure correction algoritm, can be simple or wjk
    </desc>
  </item>
  <item>
    <name>inverse.post_update_options.smooth.iterations</name>
    <desc>
      number of iterations for triangular smooth
    </desc>
  </item>
  <item>
    <name>inverse.post_update_options.splinesmooth.step</name>
    <desc>
      grid spacing for spline fit when doing spline smoothing.
    </desc>
  </item>
  <item>
    <name>inverse.p_target</name>
    <desc>
      partial pressure of this species
    </desc>
  </item>

<!-- imc specific stuff -->

  <item>
    <name>inverse.imc</name>
    <desc>Section containing inverse monte carlo specific options.</desc>
  </item>
  <item>
    <name>inverse.imc.group</name>
    <desc>
      Group of interaction. Cross-correlations of all members of a group are taken into account for calculating the update.
        I no cross correlations should be calculated, interactions have to be put into different groujps.
    </desc>
  </item>
  <item>
    <name>inverse.gromacs</name>
    <desc>
        This section contains gromacs specific options if gromacs is used as simulatiion program.
    </desc>
  </item>
  
  <item>
    <name>inverse.gromacs.table</name>
    <desc>
      Name of file for tabulated potential of this interaction. This fill will be created from the internal tabulated potential format for every run.
    </desc>
  </item>  

<!-- general inverse options -->
  <item>
    <name>cg.inverse</name><section/>
    <desc>
      general options for inverse script
    </desc>
  </item>
  
  <item><name>cg.inverse.kBT</name><desc> kBT (300*0.00831451 gromacs units) </desc></item>
  <item><name>cg.inverse.program</name><desc>simulation package to be used (currently only gromacs) </desc></item>
  <item><name>cg.inverse.gromacs</name><desc> gromacs specific options </desc></item>
  <item><name>cg.inverse.$simprog.equi_time</name><default>0.0</default><desc> begin analysis after this time </desc></item>
  <item><name>cg.inverse.$simprog.first_frame</name><default>0</default><desc> trash so many frames at the beginning </desc></item>
  <item><name>cg.inverse.gromacs.table_bins</name><desc> grid for table*.xvg !</desc></item>
  <item><name>cg.inverse.gromacs.pot_max</name><desc> cut the potential at this value (gromacs bug) </desc></item>
  <item><name>cg.inverse.gromacs.table_end</name><desc> extend the tables to this value </desc></item>
  <item><name>cg.inverse.$simprog.topol</name><desc> topology + trajectory. Be careful, do not change yet! </desc></item>
  <item><name>cg.inverse.$simprog.traj</name><desc> topology + trajectory. Be careful, do not change yet! </desc></item>
  <item><name>cg.inverse.filelist</name><desc> these files are copied for each new run </desc></item>
  <item><name>cg.inverse.iterations_max</name><desc> do so many iterations </desc></item>
  <item><name>cg.inverse.method</name><desc> ibm: inverse boltzmann imc: inverse monte carlo </desc></item>
  <item><name>cg.inverse.scriptdir</name><desc> directory for user scripts (e.g. $PWD)</desc></item>
  <item><name>cg.inverse.log_file</name><desc> write log to this file </desc></item>
  <item><name>cg.inverse.imc</name><desc> general imc specific options </desc></item>
  <item><name>cg.inverse.imc.solver</name><desc> solver to solve linear equation system, can be octave or matlab </desc></item>
  
  
  <!-- force matching stuff -->
  <item>
    <name>cg.fmatch.frames_per_block</name>
    <desc>
      number of frames, being used for block averaging. Atomistic trajectory, specified with
       --trj option, is divided into blocks and the force matching equations are solved separately for each block.
      Coarse-grained force-field, which one gets on the output is averaged over those blocks.
    </desc>
  </item>
    
  <item>
    <name>cg.fmatch.constrainedLS</name>
    <desc>
      boolean variable: false - simple least squares, true - constrained least squares.
      For details see VOTCA paper. Practically both algorithms give the same results,
      but simple least squares is faster. If you are mathematician and think that a spline
      is only then can be called spline if it has continuous first and second derivatives,
      use constrained least squares.
    </desc>
  </item>
  
  <item>
    <name>fmatch.min</name>
    <desc>
      Minimum value of interval for distribution sampled in atomistic MD simulation. One can get this
      number by looking at the distribution function for this interaction. For non-bonded interactions
      it's the distance the rdf starts. For CG bonds and angles the variable has the similar meaning
      ( note, that for angles it is specified in radians ).
    </desc>
  </item>
  
  <item>
    <name>fmatch.max</name>
    <desc>
      Maximum value of interval for distribution sampled in atomistic MD simulation. One can get this
      number by looking at the distribution function for this interaction. For non-bonded interactions
      it's the cut-off fot the interaction.
    </desc>
  </item>

  <item>
    <name>fmatch.step</name>
    <desc>
      grid spacing for the spline, which represents the interaction. This parameter should not be too big,
      otherwise you might lose some features of the interaction potential, and not too small, otherwise you
      will have unsampled bins which results in a ill-defines equation system and will get NaNs in the output.
    </desc>
  </item>

  <item>
    <name>fmatch.out_step</name>
    <desc>
      Grid spacing for the output grid. Normally one wants to have this parameter smaller than fmatch.step, 
      to have smooth curve, without additional spline interpolation. As a rule of thumb we normally use
      fmatch.out_step which is approximately 5 times smaller than fmatch.step.
    </desc>
  </item>
</tags>
